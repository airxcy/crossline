#include <opencv2/opencv.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>
#include <fstream>
#include <queue>
//#include "lkdlist.h"

using namespace cv;

#define IMGTYPE CV_8UC1
#define imgTypeC CV_8UC3
int getLineIdx(std::vector<int>& x_idx,std::vector<int>& y_idx,int* PointA,int* PointB);
class VideoIStream
{
public:
	VideoIStream();
	VideoIStream(std::string fname);
	~VideoIStream();
	bool init_VideoIStream(int l);
	bool init_VideoIStream(int w,int h,int l);
	void initBuffs();
	bool readFrame(Mat& frame);
	void updateBuff(unsigned char* new_frame_ptr);
	bool releaseStream();
	bool isVid;
	int frameidx;
	char strbuff[200];

	Mat video_buff;
	VideoCapture vid_cpt;
	string fname_str;

	int headidx,tailidx,width,height,buff_len,frame_byte_size;
	unsigned char *headptr, *tailptr, *cur_frame_ptr;
};

class LineSlice
{
public:
	LineSlice();
	~LineSlice();

	int init(std::vector<int>& x,std::vector<int>& y,int h,int w,int l);
	void fromAFrame(unsigned char* framept);
	

	int line_len;
	int idx_N;
	int buff_len;
	int tail_idx;
	int width,height;
	std::vector<int> x_idx;
	std::vector<int> y_idx;
	Mat data_buff;
	Mat rgb_buff;
	unsigned char* rgb_ptr;
	unsigned char* data_ptr;
	unsigned char* tail_ptr;

};
class BGModel : public VideoIStream
{
public:
	BGModel():VideoIStream(){noGT=false;}
	BGModel(std::string fname):VideoIStream(fname){noGT=false;}
	~BGModel(){};

	bool noGT;
	Mat fgMaskMOG; //fg mask generated by MOG method
	

	BackgroundSubtractorMOG2 pMOG;

	bool init_BGStream(int l);
	bool init_BGStream(int w,int h,int l);
	bool getBgMask(Mat& frame,Mat& mask);
	void initpMOG();
};

class GTLabel
{
public:

	GTLabel(){bool hasGT=false;}
	~GTLabel(){}

	GTLabel(vector<int>& x,vector<int>& y,int l,string fname,int maxppl)
	{
		max_ppl=maxppl;
		buff_len = l;
		locX=new float[l*maxppl];
		locY=new float[l*maxppl];
		ppl_idx=new int[l*maxppl];
		frameidx=vector<int>(l,0);
		pplN=vector<int>(l,0);
		head=0;tail=0;
		fname_str=fname;
		que_len=0;

		line_x=x;
		line_y=y;
		idx_N=line_x.size();
		cross_idx = new int[buff_len*maxppl];
		cross_pos = new int[buff_len*maxppl];
		cross_N = vector<int>(buff_len,0);
		cross_tail=0,cross_head=0;
		crossedSum=vector<int>(buff_len,0);
		curCrossSum=0;
		hasGT=false;
	};

	string fname_str;
	int buff_len,max_ppl;
	float* locX;
	float* locY;
	int* ppl_idx;
	int que_len;
	char errstrbuff[100];
	vector<int> frameidx;
	vector<int> pplN;
	vector<int> line_x;
	vector<int> line_y;
	
	int idx_N;
	int* cross_idx;
	int* cross_pos;
	vector<int> cross_N;
	int cross_tail,cross_head;
	vector<int> crossedSum;
	int curCrossSum;
	int head, tail;
	bool hasGT;


	int loadXYIdx(int frameidx);
	bool DrawLabelsFrame(Mat& frame);
	bool updateGTCross();
	void drawLabelsSlice(Mat& frame);
};
class Feature
{
public:
	Feature(){};
	~Feature(){};
	Feature(int l)
	{
		buff_len=l,head=0,tail=0;
		areavect = vector<int>(buff_len);
		dim=1;
		feat_N=0;
		cur_Size=100;
		featset = new  float[cur_Size*dim];
		countset= new float[cur_Size];
		curfeat= new float[dim];
		curArea=0;
	}
	int dim;
	int head,tail,buff_len;
	vector<int> areavect;
	int curArea;

	float* featset;//(buff_len);
	float* curfeat;
	float* countset;
	int feat_N;
	int cur_Size;
	Mat variance;
	Scalar cmean ;
	float meanvar;
	Mat stdDev;

	void updateFeat(Mat& bg_slice);
	void updateFeatCount(int count);
};
class Regression
{
public:
	Regression(){};
	~Regression(){};
	Regression(int l,Feature& feat)
	{
		buff_len=l,head=0,tail=0;
		countvec = vector<float>(buff_len,0);
		beta=Mat::ones(feat.dim,1,CV_32F);
		epsilon=Mat::zeros(feat.dim,1,CV_32F);
		curcount=0;
	};
	int head,tail,buff_len;
	vector<float> countvec;
	float curcount;
	Mat beta;
	Mat epsilon;

	void IDLinear(Feature &feat);
	void updateIDLinear(Feature &feat);
};
/*
class Tracker
{
public:
	Tracker(){};
	~Tracker(){};
	Tracker(string fname)
	{
		hastracker=false;
		filename = fname;
		txtfile.open(filename);
		if(txtfile.is_open())
		{
			hastracker=true;
		}
		int frame_idx=0;
	};
	bool hastracker;
	string filename;
	int frame_idx;
	std::ifstream txtfile;
	cur
	void updateAFrame(Mat &frame);
};
*/